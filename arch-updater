#!/bin/sh

set -e

generateAnsiColors() {
    for i in 0:BLACK 1:RED 2:GREEN 3:YELLOW 4:BLUE 5:MAGENTA 6:CYAN 7:WHITE; do
        NAME="${i#*:}"
        CODE="${i%:*}"
        F_CODE=$(( CODE + 30 ))
        FB_CODE=$(( CODE + 90 ))
        if [ "$1" = "shell" ]; then
            printf "%s='\033[0;%im' " "$NAME" "$F_CODE"
            printf "H_%s='\033[0;%im' " "$NAME" "$FB_CODE"
        elif [ "$1" = "awk" ]; then
            printf -- "-v %s=\033[0;%im " "$NAME" "$F_CODE"
            printf -- "-v H_%s=\033[0;%im " "$NAME" "$FB_CODE"
        else
            printf -- "--arg %s \033[0;%im " "$NAME" "$F_CODE"
            printf -- "--arg H_%s \033[0;%im " "$NAME" "$FB_CODE"
        fi
    done
    if [ "$1" = "shell" ]; then
        printf "RESET='\033[0m' "
    elif [ "$1" = "awk" ]; then
        printf -- "-v RESET=\033[0m "
    else
        printf -- "--arg RESET \033[0m "
    fi
}

eval "$(generateAnsiColors shell)"
AWK_COLORS="$(generateAnsiColors awk)"

NL='
'

if [ -n "$UPGRADE_PACKAGE_LIST_FILE" ] \
    && [ -n "$UPGRADE_SKIP_LIST_FILE" ] \
    && [ -n "$UNIMPORTANT_PACKAGE_LIST_FILE" ] \
    && [ -n "$PACKAGE_INFO_CACHE_DIR" ]
then

    UPGRADE_SKIP_LIST=" $(cat "$UPGRADE_SKIP_LIST_FILE") "
    UNIMPORTANT_PACKAGE_LIST=" $(cat "$UNIMPORTANT_PACKAGE_LIST_FILE") "

    if command -v arch-log >/dev/null 2>&1; then
        HAS_ARCHLOG=1
    else
        HAS_ARCHLOG=0
    fi

    getPackageInfo() {

        INFO_KIND="$1"
        PACKAGE="$(echo "$2" | awk '{print $3}')"
        SOURCE="$(echo "$2" | awk '{print $2}')"
        VER_OLD="$(echo "$2" | awk '{print $4}')"
        PACKAGE_INFO_CACHE_INFO="$PACKAGE_INFO_CACHE_DIR/info.$PACKAGE"
        PACKAGE_INFO_CACHE_URL="$PACKAGE_INFO_CACHE_DIR/url.$PACKAGE"
        PACKAGE_INFO_CACHE_ARCHLOG="$PACKAGE_INFO_CACHE_DIR/archlog.$PACKAGE"
        PACKAGE_INFO_CACHE_ISSUES="$PACKAGE_INFO_CACHE_DIR/issues.$PACKAGE"

        if [ ! -e "$PACKAGE_INFO_CACHE_INFO" ]; then
            {
                if [ "$SOURCE" = "[PAC]" ]; then
                    # pacman -Si "$PACKAGE" --color never | sed -n '/^Repository/,/^$/p' | awk '/^Repository/ {count++} count==1'
                    pacman -Qi "$PACKAGE" --color never
                elif [ "$SOURCE" = "[AUR]" ]; then
                    yay -Qi "$PACKAGE" --color never
                fi
            } | while IFS= read -r LINE; do
                case "$LINE" in
                    URL\ *)
                        echo "$LINE" | sed 's/^[^:]*: //' > "$PACKAGE_INFO_CACHE_URL"
                        # shellcheck disable=SC2153
                        LINE="$(echo "$LINE" | sed "s/^\([^:]*: \)\(.*\)/\1${H_BLUE}\2${RESET}/")"
                        ;;
                esac
                echo "$LINE" >> "$PACKAGE_INFO_CACHE_INFO"
            done
        fi

        if [ "$INFO_KIND" = "info" ]; then

            cat "$PACKAGE_INFO_CACHE_INFO"

            if [ -e "$PACKAGE_INFO_CACHE_ISSUES" ]; then
                cat "$PACKAGE_INFO_CACHE_ISSUES"
            fi

            if [ "$HAS_ARCHLOG" -eq 1 ]; then
                echo "${CYAN}ArchLinux package changelog${H_BLACK}:${RESET}"
                echo
                if [ ! -e "$PACKAGE_INFO_CACHE_ARCHLOG" ]; then
                    STOP_VERSION="${VER_OLD%-*}"
                    # In dash, string replacement is not supported.
                    STOP_VERSION="$(echo "$STOP_VERSION" | tr ':' '-')"
                    STOP_REVISION="${VER_OLD##*-}"
                    STOP_REVISION="${STOP_REVISION%%.*}"
                    # We cache output to variable OUTPUT and then write the output
                    # to corresponding file. This trick will help to avoid creating
                    # an empty file if fzf killed the preview generation process.
                    #
                    # shellcheck disable=SC2086
                    OUTPUT="$(
                        arch-log "$PACKAGE" --reverse --number 50 \
                            | awk $AWK_COLORS \
                                -v STOP_VERSION="$STOP_VERSION" \
                                -v STOP_REVISION="$STOP_REVISION" \
                                '
                                    /^\* [0-9]{4}-[0-9]{2}-[0-9]{2} +\([^)]+\) / {
                                        match($0, /( +\(([^)]+)-([0-9]+)\))( .*)/, groups)
                                        if (groups[2] == STOP_VERSION && groups[3] < STOP_REVISION) {
                                            exit
                                        }
                                        print GREEN $1, YELLOW $2 GREEN groups[1] RESET groups[4]
                                        if (groups[2] == STOP_VERSION && groups[3] == STOP_REVISION) {
                                            exit
                                        }
                                        next
                                    }

                                    /^\* [0-9]{4}-[0-9]{2}-[0-9]{2}/ {
                                        match($0, /([0-9]{4}-[0-9]{2}-[0-9]{2})( .*)/, groups)
                                        print GREEN $1, YELLOW groups[1] RESET groups[2]
                                        next
                                    }

                                    {
                                        print $0
                                    }
                                '
                    )"
                    if [ -n "$OUTPUT" ]; then
                        echo "$OUTPUT" > "$PACKAGE_INFO_CACHE_ARCHLOG"
                        echo "$OUTPUT"
                    else
                        echo "${RED}An error occurred while fetching the package log.${RESET}"
                    fi
                else
                    cat "$PACKAGE_INFO_CACHE_ARCHLOG"
                fi
            fi

        elif [ "$INFO_KIND" = "url" ]; then

            [ ! -e "$PACKAGE_INFO_CACHE_URL" ] || cat "$PACKAGE_INFO_CACHE_URL"

        fi

    }

    if [ "$1" = "-upgrade-all" ]; then

        echo > "$UPGRADE_SKIP_LIST_FILE"

    elif [ "$1" = "-skip-all" ]; then

        UPGRADE_SKIP_LIST=' '
        while read -r PACKAGE _; do
            UPGRADE_SKIP_LIST="$UPGRADE_SKIP_LIST$PACKAGE "
        done < "$UPGRADE_PACKAGE_LIST_FILE"
        echo "$UPGRADE_SKIP_LIST" > "$UPGRADE_SKIP_LIST_FILE"

    elif [ "$1" = "-preview" ]; then

        getPackageInfo "info" "$2"

    elif [ "$1" = "-open-url" ]; then

        URL="$(getPackageInfo "url" "$2")"
        [ -z "$URL" ] || xdg-open "$URL"

    elif [ "$1" = "-list" ]; then

        if [ -n "$FZF_PREVIEW_LEFT" ]; then
            COLUMNS=$(( FZF_PREVIEW_LEFT - 1 - 1 - 2 ))
        else
            COLUMNS="$(tput cols)"
            COLUMNS=$(( COLUMNS / 2 - 1 - 1 ))
        fi

        LIST_UNIMPORTANT=""

        # shellcheck disable=SC2059
        getLine() {
            if [ "$IS_SKIP" -eq 0 ]; then
                printf "${H_BLACK}[${GREEN}UPGR${H_BLACK}]${RESET} "
            else
                printf "${H_BLACK}[${RED}SKIP${H_BLACK}]${RESET} "
            fi

            case "$SOURCE" in
                P) printf "${H_BLACK}[${BLUE}PAC${H_BLACK}]${RESET} ";;
                A) printf "${H_BLACK}[${YELLOW}AUR${H_BLACK}]${RESET} ";;
            esac

            if [ "$IS_UNIMPORTANT" -eq 0 ]; then
                printf "${H_WHITE}%s${RESET} " "$PACKAGE"
            else
                printf "${RESET}%s " "$PACKAGE"
            fi

            printf "${CYAN}%s${RESET} " "$VER_OLD"

            printf "${H_BLACK}->${RESET} "

            if [ "$PREFIX" != "-" ]; then
                printf "${MAGENTA}%s" "$PREFIX"
            fi

            if [ "$REST" != "-" ]; then
                printf "${H_MAGENTA}%s" "$REST"
            fi

            printf "${H_BLACK}-${MAGENTA}%s${RESET}" "$REVISION"

            if [ "$ISSUES_COUNT" -gt 0 ]; then
                case "$SOURCE" in
                    P) [ "$ISSUES_COUNT" -eq 1 ] && WORD="issue" || WORD="issues";;
                    A) [ "$ISSUES_COUNT" -eq 1 ] && WORD="comment" || WORD="comments";;
                    *) [ "$ISSUES_COUNT" -eq 1 ] && WORD="unknown" || WORD="unknowns";;
                esac
                printf " ${H_BLACK}(${H_RED}%i ${RED}%s${H_BLACK})${RESET}" "$ISSUES_COUNT" "$WORD"
                LEN_ALL=$(( LEN_ALL + 4 + ${#ISSUES_COUNT} + ${#WORD} ))
            fi

            if [ "$DEP" -eq 1 ]; then
                WIDTH=$(( 6 + 1 + 5 + 1 + 1 + 1 + 2 + 1 + LEN_ALL ))
                WIDTH=$(( WIDTH + 6 ))
                if [ $WIDTH -lt $COLUMNS ]; then
                    printf "%$(( COLUMNS - WIDTH ))s" ''
                else
                    printf ' '
                fi
                printf "${H_BLACK}(dep)${RESET}"
            fi

            echo
        }

        while read -r PACKAGE VER_OLD VER_NEW SOURCE DEP PREFIX REST REVISION LEN_ALL ISSUES_COUNT; do
            case "$UNIMPORTANT_PACKAGE_LIST" in
                *" $PACKAGE "*) IS_UNIMPORTANT=1;;
                *) IS_UNIMPORTANT=0;;
            esac
            case "$UPGRADE_SKIP_LIST" in
                *" $PACKAGE "*) IS_SKIP=1;;
                *) IS_SKIP=0;;
            esac
            if [ "$IS_UNIMPORTANT" -eq 0 ]; then
                getLine
            else
                LIST_UNIMPORTANT="$LIST_UNIMPORTANT$(getLine)$NL"
            fi
        done < "$UPGRADE_PACKAGE_LIST_FILE"

        [ -z "$LIST_UNIMPORTANT" ] || printf '%s' "$LIST_UNIMPORTANT"

    elif [ "$1" = "-toggle-group" ]; then

        PACKAGE="$(echo "$2" | awk '{print $3}')"
        if [ "${UNIMPORTANT_PACKAGE_LIST#*" $PACKAGE "}" = "$UNIMPORTANT_PACKAGE_LIST" ]; then
            UNIMPORTANT_PACKAGE_LIST="$UNIMPORTANT_PACKAGE_LIST $PACKAGE"
        else
            UNIMPORTANT_PACKAGE_LIST="${UNIMPORTANT_PACKAGE_LIST%" $PACKAGE "*} ${UNIMPORTANT_PACKAGE_LIST#*" $PACKAGE "}"
        fi
        echo "$UNIMPORTANT_PACKAGE_LIST" > "$UNIMPORTANT_PACKAGE_LIST_FILE"

    elif [ "$1" = "-toggle-skip" ]; then

        PACKAGE="$(echo "$2" | awk '{print $3}')"
        if [ "${UPGRADE_SKIP_LIST#*" $PACKAGE "}" = "$UPGRADE_SKIP_LIST" ]; then
            UPGRADE_SKIP_LIST="$UPGRADE_SKIP_LIST $PACKAGE"
        else
            UPGRADE_SKIP_LIST="${UPGRADE_SKIP_LIST%" $PACKAGE "*} ${UPGRADE_SKIP_LIST#*" $PACKAGE "}"
        fi
        echo "$UPGRADE_SKIP_LIST" > "$UPGRADE_SKIP_LIST_FILE"

    fi

    exit 0
fi

SELF_DIR="$(cd "$(dirname "$0")"; pwd)"
SELF_FILE="$SELF_DIR/$(basename "$0")"

# shellcheck disable=SC2329
cleanup() {
    set +e
    {
        for TEMP_FN in \
            "$ISSUES_CURL_FILE" \
            "$UPGRADE_PACKAGE_LIST_FILE" \
            "$UPGRADE_PACKAGE_WITH_ISSUES_LIST_FILE" \
            "$UPGRADE_SKIP_LIST_FILE" \
            "$PACKAGE_LIST_PACMAN" \
            "$PACKAGE_LIST_AUR"
        do
            [ -z "$TEMP_FN" ] || rm -f "$TEMP_FN"
        done
        for TEMP_DIR in \
            "$CURL_OUTPUT_ISSUES_PACMAN" \
            "$PACKAGE_INFO_CACHE_DIR"
        do
            [ -z "$TEMP_DIR" ] || rm -rf "$TEMP_DIR"
        done
    } >/dev/null 2>&1
    exit "$1"
}

trap 'cleanup $?' EXIT INT TERM HUP

unset \
    ISSUES_CURL_FILE \
    UNIMPORTANT_PACKAGE_LIST_FILE \
    ISSUES_CACHE_DIR \
    UPGRADE_PACKAGE_LIST_FILE \
    UPGRADE_SKIP_LIST_FILE \
    PACKAGE_INFO_CACHE_DIR

command -v curl >/dev/null 2>&1 && HAS_CURL=1 || HAS_CURL=0
command -v jq >/dev/null 2>&1 && HAS_JQ=1 || HAS_JQ=0
command -v expac >/dev/null 2>&1 && HAS_EXPAC=1 || HAS_EXPAC=0

if [ "$HAS_CURL" -eq 1 ] && [ "$HAS_JQ" -eq 1 ] && [ "$HAS_EXPAC" -eq 1 ]; then
    CAN_FETCH_PACMAN_ISSUES=1
else
    echo
    echo "${H_BLACK}[${YELLOW}WARNING${H_BLACK}]${RESET} package issue will not be shown because some necessary utilities are not installed, please check that packages ${CYAN}curl${RESET}, ${CYAN}jq${RESET} and ${CYAN}expac${RESET} are installed."
    CAN_FETCH_PACMAN_ISSUES=0
fi

CONFIG_DIR="${XDG_CONFIG_HOME:-$HOME/.config}/arch-updater"
mkdir -p "$CONFIG_DIR"
UNIMPORTANT_PACKAGE_LIST_FILE="$CONFIG_DIR/unimportant-packages.list"
export UNIMPORTANT_PACKAGE_LIST_FILE
[ -e "$UNIMPORTANT_PACKAGE_LIST_FILE" ] || touch "$UNIMPORTANT_PACKAGE_LIST_FILE"

ISSUES_CACHE_DIR="${XDG_CACHE_DIR:-$HOME/.cache}/arch-updater/package-issues"
mkdir -p "$ISSUES_CACHE_DIR"

UPGRADE_PACKAGE_LIST_FILE="$(mktemp)"
export UPGRADE_PACKAGE_LIST_FILE

UPGRADE_SKIP_LIST_FILE="$(mktemp)"
export UPGRADE_SKIP_LIST_FILE

PACKAGE_INFO_CACHE_DIR="$(mktemp -d)"
export PACKAGE_INFO_CACHE_DIR

HEADER="$(printf '%s\n' \
    "SPACE:     Toggle skip/upgrade | CTRL-A: Upgrade all       | CTRL-U: Skip all" \
    "ENTER:     Open URL            | CTRL-S: Toggle importance" \
    "ALT-ENTER: Start upgrade       | ESC:    Exit" \
)"

ISSUE_FILE_STAMP="$(date --utc +%Y%m%d%H)"

JQ_COLORS="$(generateAnsiColors jq)"

getIssueCacheFile() {
    PACKAGE="$1"
    echo "$ISSUES_CACHE_FILE"
}

stage() {
    echo "${GREEN}* ${RESET}$1 ${H_BLACK}...${RESET}"
}

while true; do

    echo
    stage "Get pacman updated package list..."
    PACKAGE_LIST_PACMAN="$(mktemp)"
    checkupdates --nocolor > "$PACKAGE_LIST_PACMAN"

    stage "Get AUR updated package list..."
    PACKAGE_LIST_AUR="$(mktemp)"
    yay -Qua --color never > "$PACKAGE_LIST_AUR"

    {
        pacman -Qd | tr '\n' ' ' | awk '
            NR == FNR {
                for (i = 1; i <= NF; i++) {
                    dep[$i] = 1
                }
                next
            }

            {
                if ($1 in dep) {
                    print $1, $2, $4, "P", "1"
                } else {
                    print $1, $2, $4, "P", "0"
                }
            }
        ' - "$PACKAGE_LIST_PACMAN"
        awk '
            {
                print $1, $2, $4, "A", "0"
            }
        ' "$PACKAGE_LIST_AUR"
    } | sort | awk '
        {
            len1 = length($2)
            len2 = length($3)
            len_all = length($1) + len1 + len2
            min_len = (len1 < len2) ? len1 : len2
            prefix = ""
            revision = ""
            for (i = 1; i <= min_len; i++) {
                char1 = substr($2, i, 1)
                char2 = substr($3, i, 1)
                if (char1 != "-" && char1 == char2) {
                    prefix = prefix char1
                } else {
                    break
                }
            }
            if (prefix == "") {
                prefix = "-"
                rest = $3
            } else {
                rest = substr($3, length(prefix) + 1)
            }

            if (rest != "") {
                if (match(rest, /.*-/)) {
                    revision = substr(rest, RLENGTH + 1)
                    rest = substr(rest, 1, RLENGTH - 1)
                } else {
                    revision = rest
                    rest = "-"
                }
            }

            if (revision == "") {
                revision = "-"
            }

            if (rest == "") {
                rest = "-"
            }

            print $0, prefix, rest, revision, len_all
        }
    ' > "$UPGRADE_PACKAGE_LIST_FILE"

    rm -f "$PACKAGE_LIST_PACMAN" "$PACKAGE_LIST_AUR"
    unset PACKAGE_LIST_PACMAN PACKAGE_LIST_AUR

    unset FETCH_ISSUES_PACMAN

    stage "Verify generated package list..."
    while read -r PACKAGE VER_OLD VER_NEW SOURCE DEP PREFIX REST REVISION LEN_ALL; do
        CHECK_REVISION="${VER_NEW##*-}"
        CHECK_VERSION="${VER_NEW%-*}"
        if [ "$REVISION" != "$CHECK_REVISION" ]; then
            echo "Something wrong with revision: $PACKAGE $VER_OLD $VER_NEW $SOURCE $DEP $PREFIX $REST $REVISION $LEN_ALL"
            exit 1
        fi
        if [ "$PREFIX" = "-" ]; then
            if [ "$REST" != "$CHECK_VERSION" ]; then
                echo "Something wrong with rest: $PACKAGE $VER_OLD $VER_NEW $SOURCE $DEP $PREFIX $REST $REVISION $LEN_ALL"
                exit 1
            fi
        elif [ "$REST" = "-" ]; then
            if [ "$PREFIX" != "$CHECK_VERSION" ]; then
                echo "Something wrong with prefix: $PACKAGE $VER_OLD $VER_NEW $SOURCE $DEP $PREFIX $REST $REVISION $LEN_ALL"
                exit 1
            fi
        else
            if [ "$PREFIX$REST" != "$CHECK_VERSION" ]; then
                echo "Something wrong with prefix+rest: $PACKAGE $VER_OLD $VER_NEW $SOURCE $DEP $PREFIX $REST $REVISION $LEN_ALL"
                exit 1
            fi
        fi
        if [ "$SOURCE" = "P" ] && [ "$CAN_FETCH_PACMAN_ISSUES" -eq 1 ]; then
            ISSUES_CACHE_FILE="$ISSUES_CACHE_DIR"/pkg."$PACKAGE".stamp-"$ISSUE_FILE_STAMP"
            if [ ! -e "$ISSUES_CACHE_FILE" ] && [ ! -e "${ISSUES_CACHE_FILE}.empty" ]; then
                rm -f "$ISSUES_CACHE_DIR"/pkg."$PACKAGE".stamp-*
                FETCH_ISSUES_PACMAN="$FETCH_ISSUES_PACMAN$PACKAGE "
            fi
        fi
    done < "$UPGRADE_PACKAGE_LIST_FILE"

    if [ -n "$FETCH_ISSUES_PACMAN" ]; then

        CURL_OUTPUT_ISSUES_PACMAN="$(mktemp -d)"

        stage "Generate URLs for package issues list..."
        PACMAN_LIST_FILE="$CURL_OUTPUT_ISSUES_PACMAN"/pacman.list
        CURL_CONFIG_FILE="$CURL_OUTPUT_ISSUES_PACMAN"/curl-config.list
        CURL_RESULT_FILE="$CURL_OUTPUT_ISSUES_PACMAN"/curl-result.list
        # shellcheck disable=SC2086
        TZ=UTC expac -Q -t "%FT%TZ" "%e %b %n" $FETCH_ISSUES_PACMAN > "$PACMAN_LIST_FILE"
        cut -d' ' -f1-2 < "$PACMAN_LIST_FILE" | sort -u | jq -Rr --arg outputDir "$CURL_OUTPUT_ISSUES_PACMAN" '
            split("\n")
            | .[]
            | split(" ") as $p
            | [
                $p[0],
                ($p[1] | @uri),
                ("archlinux/packaging/packages/\($p[0])" | gsub("\\+"; "plus") | @uri)
              ]
            | "url=https://gitlab.archlinux.org/api/v4/projects/\(.[2])/issues?state=opened&created_after=\(.[1])"
              + "\n"
              + "output=\($outputDir)/pkg.\(.[0]).json"
              + "\n"
        ' > "$CURL_CONFIG_FILE"

        stage "Download package issues..."
        curl --silent \
            --parallel --parallel-immediate --parallel-max 10 \
            --write-out "%{response_code} %{filename_effective}\n" \
            --config "$CURL_CONFIG_FILE" > "$CURL_RESULT_FILE"

        stage "Process package issues..."

        # Delete 'empty' files (exactly 2 bytes '[]')
        find "$CURL_OUTPUT_ISSUES_PACMAN" -type f -size 2c -delete

        ERROR_COUNT=0
        while read -r RESPONSE_CODE OUTPUT_FILE; do
            [ "$RESPONSE_CODE" != 200 ] || continue
            PACKAGE="${OUTPUT_FILE##*/}"
            PACKAGE="${PACKAGE#*.}"
            PACKAGE="${PACKAGE%.*}"
            if [ "$RESPONSE_CODE" = "404" ]; then
                echo "${H_BLACK}[${YELLOW}WARNING${H_BLACK}]${RESET} got ${RED}404${RESET} response code for package: ${CYAN}$PACKAGE${RESET}"
                mv "$OUTPUT_FILE" "${OUTPUT_FILE}.error"
            else
                echo "${H_BLACK}[${RED}ERROR${H_BLACK}]${RESET} got ${RED}$RESPONSE_CODE${RESET} response code for package: ${CYAN}$PACKAGE${RESET}"
                mv "$OUTPUT_FILE" "${OUTPUT_FILE}.error"
                ERROR_COUNT=$(( ERROR_COUNT + 1 ))
            fi
        done < "$CURL_RESULT_FILE"

        while read -r PACKAGE_BASE _ PACKAGE; do
            OUTPUT_FILE="$CURL_OUTPUT_ISSUES_PACMAN"/pkg."$PACKAGE_BASE".json
            ISSUES_CACHE_FILE="$ISSUES_CACHE_DIR"/pkg."$PACKAGE".stamp-"$ISSUE_FILE_STAMP"
            if [ -e "$OUTPUT_FILE" ]; then
                cp "$OUTPUT_FILE" "$ISSUES_CACHE_FILE"
            elif [ ! -e "${OUTPUT_FILE}.error" ]; then
                # this is 'touch' without calling external tool
                printf '' > "${ISSUES_CACHE_FILE}.empty"
            fi
        done < "$PACMAN_LIST_FILE"

        rm -rf "$CURL_OUTPUT_ISSUES_PACMAN"
        unset CURL_OUTPUT_ISSUES_PACMAN

        if [ "$ERROR_COUNT" -gt 0 ]; then
            echo
            printf "Press Enter to continue..."
            read -r _
        fi

    fi

    rm -f "$PACKAGE_INFO_CACHE_DIR/issues".*
    if [ "$CAN_FETCH_PACMAN_ISSUES" -eq 1 ]; then
        stage "Render package issues..."
    fi

    UPGRADE_PACKAGE_WITH_ISSUES_LIST_FILE="$(mktemp)"
    while read -r PACKAGE VER_OLD VER_NEW SOURCE DEP PREFIX REST REVISION LEN_ALL; do
        ISSUES_COUNT=0
        if [ "$SOURCE" = "P" ]; then
            if [ "$CAN_FETCH_PACMAN_ISSUES" -eq 1 ]; then
                ISSUES_CACHE_FILE="$ISSUES_CACHE_DIR"/pkg."$PACKAGE".stamp-"$ISSUE_FILE_STAMP"
                if [ -e "$ISSUES_CACHE_FILE" ]; then
                    PACKAGE_INFO_CACHE_ISSUES="$PACKAGE_INFO_CACHE_DIR/issues.$PACKAGE"
                    #      | gsub("\n```(?<type>[^\n]*)(?<code>.*)\n```"; "\n" + $H_BLACK + "```" + $BLUE + .type + $GREEN + .code + $H_BLACK + "\n```" + $RESET)
                    # shellcheck disable=SC2086
                    jq -r $JQ_COLORS '
                      .[]
                      | (
                          .description
                          | gsub("<!--[^>]*-->"; "")
                          | gsub("(^|\\n+)(?<hash>#+\\s+)(?<title>.*)\\n+"; "\n\n" + $H_MAGENTA + .hash + $MAGENTA + .title + $RESET + "\n\n")
                          | gsub("(^|\\n+)```(?<type>[^\n]*)(?<code>.+)\\n```"; "\n\n" + $H_BLACK + "```" + $BLUE + .type + $GREEN + .code + "\n" + $H_BLACK + "```" + $RESET; "m")
                          | gsub("`(?<text>[^`\\n]+)`"; $H_BLACK + "`" + $GREEN + .text + $H_BLACK + "`" + $RESET)
                          | gsub("^\\n+"; "")
                          | gsub("\\n+$"; "")
                          | gsub("\\n{2,}"; "\n\n")
                        ) as $description
                      | $RED + "Issue" + $H_BLACK + "#" + $H_RED + "\(.iid)" + $H_BLACK + ": " + $RESET + .title + "\n" +
                        $CYAN + "Created" + $H_BLACK + ": " + $RESET + .created_at + "\n" +
                        $CYAN + "URL" + $H_BLACK + ": " + $H_BLUE + .web_url + $RESET + "\n" +
                        $CYAN + "Description" + $H_BLACK + ":" + $RESET + "\n\n" +
                        $description + "\n"
                    ' "$ISSUES_CACHE_FILE" > "$PACKAGE_INFO_CACHE_ISSUES"
                    ISSUES_COUNT="$(jq 'length' "$ISSUES_CACHE_FILE")"
                fi
            fi
        elif [ "$SOURCE" = "A" ]; then
            : no-op
        else
            echo "That's not supposed to happen." >&2
            exit 1
        fi
        echo "$PACKAGE" "$VER_OLD" "$VER_NEW" "$SOURCE" "$DEP" "$PREFIX" "$REST" "$REVISION" "$LEN_ALL" "$ISSUES_COUNT"
    done < "$UPGRADE_PACKAGE_LIST_FILE" > "$UPGRADE_PACKAGE_WITH_ISSUES_LIST_FILE"

    mv -f "$UPGRADE_PACKAGE_WITH_ISSUES_LIST_FILE" "$UPGRADE_PACKAGE_LIST_FILE"
    unset UPGRADE_PACKAGE_WITH_ISSUES_LIST_FILE

    SELECTED="$("$SELF_FILE" -list | fzf --ansi --disabled --reverse --no-input \
        --highlight-line \
        --header "$HEADER" --header-border \
        --preview "'$SELF_FILE' -preview {}" \
        --preview-window wrap \
        --bind "space:execute-silent('$SELF_FILE' -toggle-skip {})+down+reload-sync('$SELF_FILE' -list)" \
        --bind "ctrl-s:execute-silent('$SELF_FILE' -toggle-group {})+reload-sync('$SELF_FILE' -list)" \
        --bind "ctrl-a:execute-silent('$SELF_FILE' -upgrade-all)+reload-sync('$SELF_FILE' -list)" \
        --bind "ctrl-u:execute-silent('$SELF_FILE' -skip-all)+reload-sync('$SELF_FILE' -list)" \
        --bind "enter:execute-silent('$SELF_FILE' -open-url {})" \
        --bind "alt-enter:become(echo {})")" || exit 0

    [ -n "$SELECTED" ] || exit 0

    UPGRADE_SKIP_LIST=" $(cat "$UPGRADE_SKIP_LIST_FILE") "

    set --
    while read -r PACKAGE _ VER_NEW SOURCE _; do
        if [ "$SOURCE" = "P" ]; then
            if [ "${UPGRADE_SKIP_LIST#*" $PACKAGE "}" = "$UPGRADE_SKIP_LIST" ]; then
                set -- "$@" "${PACKAGE}=${VER_NEW}"
            fi
        fi
    done < "$UPGRADE_PACKAGE_LIST_FILE"

    if [ $# -eq 0 ]; then
        echo
        echo "There are no pacman packages to update."
    else

        echo
        echo "Upgrade pacman package database ..."
        sudo pacman -Sy

        echo
        echo "Check pacman upgrade ..."

        if ! OUTPUT="$(pacman -Sp "$@" --color always)"; then
            echo "$OUTPUT"
            echo
            echo "${RED}Update check failed. Check the error output from the pacman command."
            echo "You may need to mark additional packages as dependencies, or the repository"
            echo "may already have newer versions available than the selected ones."
            echo
            echo "The package list will be updated and you will be returned to selection mode.${RESET}"
            echo
            printf "Press Enter to continue..."
            read -r _
            continue
        fi

        echo "Run pacman upgrade ..."
        pacman -S "$@" --noconfirm --color always

    fi

    set --
    while read -r PACKAGE _ VER_NEW SOURCE _; do
        if [ "$SOURCE" = "A" ]; then
            if [ "${UPGRADE_SKIP_LIST#*" $PACKAGE "}" = "$UPGRADE_SKIP_LIST" ]; then
                set -- "$@" "${PACKAGE}"
            fi
        fi
    done < "$UPGRADE_PACKAGE_LIST_FILE"

    if [ $# -eq 0 ]; then
        echo
        echo "There are no AUR packages to update."
    else
        echo
        echo "Run AUR upgrade ..."
        yay -S "$@" --color always \
            --noconfirm --sudoloop --needed \
            --answerclean None --answerdiff None \
            --answeredit None --answerupgrade None
    fi

    echo
    echo "${GREEN}All done!${RESET}"
    exit 0

done
