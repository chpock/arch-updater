#!/bin/sh

# SPDX-License-Identifier: GPL-3.0-or-later
# Copyright (C) 2025 Konstantin Kushnir <chpock@gmail.com>
# Source: https://github.com/chpock/arch-updater
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <https://www.gnu.org/licenses/>.

set -e

VERSION=0.0.0

# 2 days = 172800 seconds
AGE_THRESHOLD=172800

NL='
'

generateAnsiColors() {
    for i in 0:BLACK 1:RED 2:GREEN 3:YELLOW 4:BLUE 5:MAGENTA 6:CYAN 7:WHITE; do
        NAME="${i#*:}"
        CODE="${i%:*}"
        F_CODE=$(( CODE + 30 ))
        FB_CODE=$(( CODE + 90 ))
        if [ "$1" = "shell" ]; then
            printf "%s='\033[0;%im' " "$NAME" "$F_CODE"
            printf "H_%s='\033[0;%im' " "$NAME" "$FB_CODE"
        elif [ "$1" = "awk" ]; then
            printf -- "-v %s=\033[0;%im " "$NAME" "$F_CODE"
            printf -- "-v H_%s=\033[0;%im " "$NAME" "$FB_CODE"
        else
            printf -- "--arg %s \033[0;%im " "$NAME" "$F_CODE"
            printf -- "--arg H_%s \033[0;%im " "$NAME" "$FB_CODE"
        fi
    done
    if [ "$1" = "shell" ]; then
        printf "RESET='\033[0m' "
    elif [ "$1" = "awk" ]; then
        printf -- "-v RESET=\033[0m "
    else
        printf -- "--arg RESET \033[0m "
    fi
}

eval "$(generateAnsiColors shell)"
AWK_COLORS="$(generateAnsiColors awk)"

command -v arch-log >/dev/null 2>&1 && HAS_ARCHLOG=1 || HAS_ARCHLOG=0

if [ "$1" = "--version" ] || [ "$1" = "-v" ]; then
    echo "$VERSION"
    exit 0
elif [ "$1" = "--help" ]; then
    echo "Usage: $0 [--version|--help]"
    exit 0
fi

if [ -n "$UPGRADE_PACKAGE_LIST_FILE" ] \
    && [ -n "$UPGRADE_SKIP_LIST_FILE" ] \
    && [ -n "$UNIMPORTANT_PACKAGE_LIST_FILE" ] \
    && [ -n "$PACKAGE_INFO_CACHE_DIR" ]
then

    UPGRADE_SKIP_LIST=" $(cat "$UPGRADE_SKIP_LIST_FILE") "
    UNIMPORTANT_PACKAGE_LIST=" $(cat "$UNIMPORTANT_PACKAGE_LIST_FILE") "

    getPackageInfo() {

        INFO_KIND="$1"
        PACKAGE="$(echo "$2" | awk '{print $3}')"
        SOURCE="$(echo "$2" | awk '{print $2}')"
        VER_OLD="$(echo "$2" | awk '{print $4}')"
        PACKAGE_INFO_CACHE_INFO="$PACKAGE_INFO_CACHE_DIR/info.$PACKAGE"
        PACKAGE_INFO_CACHE_URL="$PACKAGE_INFO_CACHE_DIR/url.$PACKAGE"
        PACKAGE_INFO_CACHE_ARCHLOG="$PACKAGE_INFO_CACHE_DIR/archlog.$PACKAGE"
        PACKAGE_INFO_CACHE_ISSUES="$PACKAGE_INFO_CACHE_DIR/issues.$PACKAGE"

        if [ ! -e "$PACKAGE_INFO_CACHE_INFO" ]; then
            {
                if [ "$SOURCE" = "[PAC]" ]; then
                    pacman -Qi "$PACKAGE" --color never
                elif [ "$SOURCE" = "[AUR]" ]; then
                    yay -Qi "$PACKAGE" --color never
                fi
            } | while IFS= read -r LINE; do
                case "$LINE" in
                    URL\ *)
                        echo "$LINE" | sed 's/^[^:]*: //' > "$PACKAGE_INFO_CACHE_URL"
                        # shellcheck disable=SC2153
                        LINE="$(echo "$LINE" | sed "s/^\([^:]*: \)\(.*\)/\1${H_BLUE}\2${RESET}/")"
                        ;;
                esac
                echo "$LINE" >> "$PACKAGE_INFO_CACHE_INFO"
            done
        fi

        if [ "$INFO_KIND" = "info" ]; then

            cat "$PACKAGE_INFO_CACHE_INFO"

            if [ -e "$PACKAGE_INFO_CACHE_ISSUES" ]; then
                cat "$PACKAGE_INFO_CACHE_ISSUES"
            fi

            if [ "$HAS_ARCHLOG" -eq 1 ]; then
                echo "${CYAN}ArchLinux package changelog${H_BLACK}:${RESET}"
                echo
                if [ ! -e "$PACKAGE_INFO_CACHE_ARCHLOG" ]; then
                    STOP_VERSION="${VER_OLD%-*}"
                    # In dash, string replacement is not supported.
                    STOP_VERSION="$(echo "$STOP_VERSION" | tr ':' '-')"
                    STOP_REVISION="${VER_OLD##*-}"
                    STOP_REVISION="${STOP_REVISION%%.*}"
                    # We cache output to variable OUTPUT and then write the output
                    # to corresponding file. This trick will help to avoid creating
                    # an empty file if fzf killed the preview generation process.
                    #
                    # shellcheck disable=SC2086
                    OUTPUT="$(
                        arch-log "$PACKAGE" --reverse --number 50 \
                            | awk $AWK_COLORS \
                                -v STOP_VERSION="$STOP_VERSION" \
                                -v STOP_REVISION="$STOP_REVISION" \
                                '
                                    /^\* [0-9]{4}-[0-9]{2}-[0-9]{2} +\([^)]+\) / {
                                        match($0, /( +\(([^)]+)-([0-9]+)\))( .*)/, groups)
                                        if (groups[2] == STOP_VERSION && groups[3] < STOP_REVISION) {
                                            exit
                                        }
                                        print GREEN $1, YELLOW $2 GREEN groups[1] RESET groups[4]
                                        if (groups[2] == STOP_VERSION && groups[3] == STOP_REVISION) {
                                            exit
                                        }
                                        next
                                    }

                                    /^\* [0-9]{4}-[0-9]{2}-[0-9]{2}/ {
                                        match($0, /([0-9]{4}-[0-9]{2}-[0-9]{2})( .*)/, groups)
                                        print GREEN $1, YELLOW groups[1] RESET groups[2]
                                        next
                                    }

                                    {
                                        print $0
                                    }
                                '
                    )"
                    if [ -n "$OUTPUT" ]; then
                        echo "$OUTPUT" > "$PACKAGE_INFO_CACHE_ARCHLOG"
                        echo "$OUTPUT"
                    else
                        echo "${RED}An error occurred while fetching the package log.${RESET}"
                    fi
                else
                    cat "$PACKAGE_INFO_CACHE_ARCHLOG"
                fi
            fi

        elif [ "$INFO_KIND" = "url" ]; then

            [ ! -e "$PACKAGE_INFO_CACHE_URL" ] || cat "$PACKAGE_INFO_CACHE_URL"

        fi

    }

    if [ "$1" = "-upgrade-all" ]; then

        echo > "$UPGRADE_SKIP_LIST_FILE"

    elif [ "$1" = "-skip-all" ]; then

        UPGRADE_SKIP_LIST=' '
        while read -r PACKAGE _; do
            UPGRADE_SKIP_LIST="$UPGRADE_SKIP_LIST$PACKAGE "
        done < "$UPGRADE_PACKAGE_LIST_FILE"
        echo "$UPGRADE_SKIP_LIST" > "$UPGRADE_SKIP_LIST_FILE"

    elif [ "$1" = "-preview" ]; then

        getPackageInfo "info" "$2"

    elif [ "$1" = "-open-url" ]; then

        URL="$(getPackageInfo "url" "$2")"
        [ -z "$URL" ] || xdg-open "$URL"

    elif [ "$1" = "-list" ]; then

        if [ -n "$FZF_COLUMNS" ]; then
            if [ -n "$FZF_PREVIEW_LEFT" ]; then
                COLUMNS=$(( FZF_PREVIEW_LEFT - 1 - 1 - 2 ))
            else
                COLUMNS=$(( FZF_COLUMNS - 2 ))
            fi
        else
            COLUMNS="$(tput cols)"
            COLUMNS=$(( COLUMNS / 2 - 1 - 1 ))
        fi

        LIST_UNIMPORTANT=""

        # shellcheck disable=SC2059
        getLine() {
            if [ "$IS_SKIP" -eq 0 ]; then
                printf "${H_BLACK}[${GREEN}UPGR${H_BLACK}]${RESET} "
            else
                printf "${H_BLACK}[${RED}SKIP${H_BLACK}]${RESET} "
            fi

            case "$SOURCE" in
                P) printf "${H_BLACK}[${BLUE}PAC${H_BLACK}]${RESET} ";;
                A) printf "${H_BLACK}[${YELLOW}AUR${H_BLACK}]${RESET} ";;
            esac

            if [ "$IS_UNIMPORTANT" -eq 0 ]; then
                printf "${H_WHITE}%s${RESET} " "$PACKAGE"
            else
                printf "${RESET}%s " "$PACKAGE"
            fi

            printf "${CYAN}%s${RESET} " "$VER_OLD"

            printf "${H_BLACK}->${RESET} "

            if [ "$PREFIX" != "-" ]; then
                printf "${MAGENTA}%s" "$PREFIX"
            fi

            if [ "$REST" != "-" ]; then
                printf "${H_MAGENTA}%s" "$REST"
            fi

            printf "${H_BLACK}-${MAGENTA}%s${RESET}" "$REVISION"

            if [ "$ISSUES_COUNT" -gt 0 ]; then
                case "$SOURCE" in
                    P) [ "$ISSUES_COUNT" -eq 1 ] && WORD="issue" || WORD="issues";;
                    A) [ "$ISSUES_COUNT" -eq 1 ] && WORD="comment" || WORD="comments";;
                    *) [ "$ISSUES_COUNT" -eq 1 ] && WORD="unknown" || WORD="unknowns";;
                esac
                printf " ${H_BLACK}(${H_RED}%i ${RED}%s${H_BLACK})${RESET}" "$ISSUES_COUNT" "$WORD"
                LEN_ALL=$(( LEN_ALL + 4 + ${#ISSUES_COUNT} + ${#WORD} ))
            fi

            if [ "$AGE" != "-" ]; then
                printf " ${H_BLACK}(${RED}age${H_BLACK}: ${H_RED}%s${H_BLACK})${RESET}" "$AGE"
                LEN_ALL=$(( LEN_ALL + 8 + ${#AGE} ))
            fi

            if [ "$DEP" -eq 1 ]; then
                WIDTH=$(( 6 + 1 + 5 + 1 + 1 + 1 + 2 + 1 + LEN_ALL ))
                WIDTH=$(( WIDTH + 6 ))
                if [ $WIDTH -lt $COLUMNS ]; then
                    printf "%$(( COLUMNS - WIDTH ))s" ''
                else
                    printf ' '
                fi
                printf "${H_BLACK}(dep)${RESET}"
            fi

            echo
        }

        while read -r PACKAGE VER_OLD VER_NEW SOURCE DEP PREFIX REST REVISION LEN_ALL AGE ISSUES_COUNT; do
            case "$UNIMPORTANT_PACKAGE_LIST" in
                *" $PACKAGE "*) IS_UNIMPORTANT=1;;
                *) IS_UNIMPORTANT=0;;
            esac
            case "$UPGRADE_SKIP_LIST" in
                *" $PACKAGE "*) IS_SKIP=1;;
                *) IS_SKIP=0;;
            esac
            if [ "$IS_UNIMPORTANT" -eq 0 ]; then
                getLine
            else
                LIST_UNIMPORTANT="$LIST_UNIMPORTANT$(getLine)$NL"
            fi
        done < "$UPGRADE_PACKAGE_LIST_FILE"

        [ -z "$LIST_UNIMPORTANT" ] || printf '%s' "$LIST_UNIMPORTANT"

    elif [ "$1" = "-toggle-group" ]; then

        PACKAGE="$(echo "$2" | awk '{print $3}')"
        if [ "${UNIMPORTANT_PACKAGE_LIST#*" $PACKAGE "}" = "$UNIMPORTANT_PACKAGE_LIST" ]; then
            UNIMPORTANT_PACKAGE_LIST="$UNIMPORTANT_PACKAGE_LIST $PACKAGE"
        else
            UNIMPORTANT_PACKAGE_LIST="${UNIMPORTANT_PACKAGE_LIST%" $PACKAGE "*} ${UNIMPORTANT_PACKAGE_LIST#*" $PACKAGE "}"
        fi
        echo "$UNIMPORTANT_PACKAGE_LIST" > "$UNIMPORTANT_PACKAGE_LIST_FILE"

    elif [ "$1" = "-toggle-skip" ]; then

        PACKAGE="$(echo "$2" | awk '{print $3}')"
        if [ "${UPGRADE_SKIP_LIST#*" $PACKAGE "}" = "$UPGRADE_SKIP_LIST" ]; then
            UPGRADE_SKIP_LIST="$UPGRADE_SKIP_LIST $PACKAGE"
        else
            UPGRADE_SKIP_LIST="${UPGRADE_SKIP_LIST%" $PACKAGE "*} ${UPGRADE_SKIP_LIST#*" $PACKAGE "}"
        fi
        echo "$UPGRADE_SKIP_LIST" > "$UPGRADE_SKIP_LIST_FILE"

    fi

    exit 0
fi

SELF_DIR="$(cd "$(dirname "$0")"; pwd)"
SELF_FILE="$SELF_DIR/$(basename "$0")"

# shellcheck disable=SC2329
cleanup() {
    set +e
    {
        for TEMP_FN in \
            "$ISSUES_CURL_FILE" \
            "$UPGRADE_PACKAGE_LIST_FILE" \
            "$UPGRADE_PACKAGE_TEMP_LIST_FILE" \
            "$UPGRADE_SKIP_LIST_FILE" \
            "$PACKAGE_LIST_PACMAN" \
            "$PACKAGE_LIST_AUR" \
            "$PACKAGE_LIST_AUR_STDERR" \
            "$TEMP_RATE_LIMIT_INFO"
        do
            [ -z "$TEMP_FN" ] || rm -f "$TEMP_FN"
        done
        for TEMP_DIR in \
            "$CURL_OUTPUT_DIR" \
            "$PACKAGE_INFO_CACHE_DIR"
        do
            [ -z "$TEMP_DIR" ] || rm -rf "$TEMP_DIR"
        done
    } >/dev/null 2>&1
    exit "$1"
}

trap 'cleanup $?' EXIT INT TERM HUP

unset \
    ISSUES_CURL_FILE \
    UNIMPORTANT_PACKAGE_LIST_FILE \
    ISSUES_CACHE_DIR \
    CHANGELOG_CACHE_DIR \
    UPGRADE_PACKAGE_LIST_FILE \
    UPGRADE_SKIP_LIST_FILE \
    PACKAGE_INFO_CACHE_DIR

command -v curl >/dev/null 2>&1 && HAS_CURL=1 || HAS_CURL=0
command -v jq >/dev/null 2>&1 && HAS_JQ=1 || HAS_JQ=0
command -v expac >/dev/null 2>&1 && HAS_EXPAC=1 || HAS_EXPAC=0

if [ "$HAS_CURL" -eq 1 ] && [ "$HAS_JQ" -eq 1 ] && [ "$HAS_EXPAC" -eq 1 ]; then
    CAN_FETCH_PACMAN_ISSUES=1
else
    echo
    echo "${H_BLACK}[${YELLOW}WARNING${H_BLACK}]${RESET} package issue will not be shown because some necessary utilities are not installed, please check that packages ${CYAN}curl${RESET}, ${CYAN}jq${RESET} and ${CYAN}expac${RESET} are installed."
    CAN_FETCH_PACMAN_ISSUES=0
fi

if [ "$HAS_CURL" -eq 1 ] && [ "$HAS_JQ" -eq 1 ]; then
    CAN_FETCH_PACMAN_CHANGELOG=1
    CAN_FETCH_AUR_CHANGELOG=1
elif [ "$HAS_ARCHLOG" -eq 1 ]; then
    echo "${H_BLACK}[${CYAN}INFO${H_BLACK}]${RESET} package changelog will be fetched using the ${CYAN}arch-log${RESET} utility, please check that packages ${CYAN}curl${RESET} and ${CYAN}jq${RESET} for better performance."
    CAN_FETCH_PACMAN_ISSUES=0
    CAN_FETCH_AUR_CHANGELOG=0
else
    echo
    echo "${H_BLACK}[${YELLOW}WARNING${H_BLACK}]${RESET} package changelog will not be shown because some necessary utilities are not installed, please check that packages ${CYAN}curl${RESET}, ${CYAN}jq${RESET} or ${CYAN}arch-log${RESET} are installed."
    CAN_FETCH_PACMAN_ISSUES=0
    CAN_FETCH_AUR_CHANGELOG=0
fi

CONFIG_DIR="${XDG_CONFIG_HOME:-$HOME/.config}/arch-updater"
mkdir -p "$CONFIG_DIR"
UNIMPORTANT_PACKAGE_LIST_FILE="$CONFIG_DIR/unimportant-packages.list"
export UNIMPORTANT_PACKAGE_LIST_FILE
[ -e "$UNIMPORTANT_PACKAGE_LIST_FILE" ] || touch "$UNIMPORTANT_PACKAGE_LIST_FILE"

ISSUES_CACHE_DIR="${XDG_CACHE_DIR:-$HOME/.cache}/arch-updater/package-issues"
CHANGELOG_CACHE_DIR="${XDG_CACHE_DIR:-$HOME/.cache}/arch-updater/package-changelog"
mkdir -p "$ISSUES_CACHE_DIR" "$CHANGELOG_CACHE_DIR"

UPGRADE_PACKAGE_LIST_FILE="$(mktemp)"
export UPGRADE_PACKAGE_LIST_FILE

UPGRADE_SKIP_LIST_FILE="$(mktemp)"
export UPGRADE_SKIP_LIST_FILE

PACKAGE_INFO_CACHE_DIR="$(mktemp -d)"
export PACKAGE_INFO_CACHE_DIR

FOOTER="$(printf '%s\n' \
    "SPACE:     Toggle skip/upgrade | CTRL-A: Upgrade all       | CTRL-U: Skip all" \
    "ENTER:     Open URL            | CTRL-S: Toggle importance | ?:      Toggle details" \
    "ALT-ENTER: Start upgrade       | ESC:    Exit" \
)"

ISSUE_FILE_STAMP="$(date --utc +%Y%m%d%H)"

JQ_COLORS="$(generateAnsiColors jq)"

getIssueCacheFile() {
    PACKAGE="$1"
    echo "$ISSUES_CACHE_FILE"
}

stage() {
    echo "${GREEN}* ${RESET}$1 ${H_BLACK}...${RESET}"
}

waitRateLimit() {
    WAIT_TIME="$1"
    MESSAGE="$2"
    START_TIME="$(date +%s)"
    while true; do
        CURRENT_TIME="$(date +%s)"
        LEFT=$(( START_TIME - CURRENT_TIME + WAIT_TIME ))
        [ "$LEFT" -gt 0 ] || break
        [ "$LEFT" -eq 1 ] && WORD="second" || WORD="seconds"
        printf "\rIn ${BLUE}%s${RESET} %s, %s\033[K" "$LEFT" "$WORD" "$MESSAGE"
        sleep 1
    done
    printf '\r\033[K'
}

while true; do

    HAS_UPDATES_PACMAN=1
    HAS_UPDATES_AUR=1

    if [ -f /var/lib/pacman/db.lck ]; then
        echo "ERROR: Packman database is locked, lockfile (/var/lib/pacman/db.lck) exists. Another process might be running." >&2
        echo >&2
        echo "Please restart this utility when the database is free." >&2
        exit 1
    fi

    echo
    stage "Get pacman updated package list"
    [ -n "$PACKAGE_LIST_PACMAN" ] || PACKAGE_LIST_PACMAN="$(mktemp)"
    checkupdates --nocolor > "$PACKAGE_LIST_PACMAN" && R=0 || R=$?

    if [ "$R" -eq 2 ]; then
        echo "No updates."
        HAS_UPDATES_PACMAN=0
    elif [ "$R" -ne 0 ]; then
        exit "$R"
    fi

    stage "Get AUR updated package list"
    [ -n "$PACKAGE_LIST_AUR" ] || PACKAGE_LIST_AUR="$(mktemp)"
    [ -n "$PACKAGE_LIST_AUR_STDERR" ] || PACKAGE_LIST_AUR_STDERR="$(mktemp)"
    yay -Qua --color never > "$PACKAGE_LIST_AUR" 2> "$PACKAGE_LIST_AUR_STDERR" && R=0 || R=$?

    [ ! -s "$PACKAGE_LIST_AUR_STDERR" ] || cat "$PACKAGE_LIST_AUR_STDERR" >&2

    if [ "$R" -eq 1 ]; then
        if [ -s "$PACKAGE_LIST_AUR_STDERR" ]; then
            exit "$R"
        else
            echo "No updates."
            HAS_UPDATES_AUR=0
        fi
    elif [ "$R" -ne 0 ]; then
        exit "$R"
    fi

    rm -f "$PACKAGE_LIST_AUR_STDERR"
    unset PACKAGE_LIST_AUR_STDERR

    [ "$HAS_UPDATES_PACMAN" -eq 0 ] && [ "$HAS_UPDATES_AUR" -eq 0 ] && exit 0 || :

    {
        pacman -Qd | tr '\n' ' ' | awk '
            NR == FNR {
                for (i = 1; i <= NF; i++) {
                    dep[$i] = 1
                }
                next
            }

            {
                if ($1 in dep) {
                    print $1, $2, $4, "P", "1"
                } else {
                    print $1, $2, $4, "P", "0"
                }
            }
        ' - "$PACKAGE_LIST_PACMAN"
        awk '
            {
                print $1, $2, $4, "A", "0"
            }
        ' "$PACKAGE_LIST_AUR"
    } | sort | awk '
        {
            len1 = length($2)
            len2 = length($3)
            len_all = length($1) + len1 + len2
            min_len = (len1 < len2) ? len1 : len2
            prefix = ""
            revision = ""
            for (i = 1; i <= min_len; i++) {
                char1 = substr($2, i, 1)
                char2 = substr($3, i, 1)
                if (char1 != "-" && char1 == char2) {
                    prefix = prefix char1
                } else {
                    break
                }
            }
            if (prefix == "") {
                prefix = "-"
                rest = $3
            } else {
                rest = substr($3, length(prefix) + 1)
            }

            if (rest != "") {
                if (match(rest, /.*-/)) {
                    revision = substr(rest, RLENGTH + 1)
                    rest = substr(rest, 1, RLENGTH - 1)
                } else {
                    revision = rest
                    rest = "-"
                }
            }

            if (revision == "") {
                revision = "-"
            }

            if (rest == "") {
                rest = "-"
            }

            print $0, prefix, rest, revision, len_all
        }
    ' > "$UPGRADE_PACKAGE_LIST_FILE"

    rm -f "$PACKAGE_LIST_PACMAN" "$PACKAGE_LIST_AUR"
    unset PACKAGE_LIST_PACMAN PACKAGE_LIST_AUR

    unset FETCH_ISSUES_PACMAN FETCH_CHANGELOG_PACMAN FETCH_CHANGELOG_AUR

    stage "Verify generated package list"
    while read -r PACKAGE VER_OLD VER_NEW SOURCE DEP PREFIX REST REVISION LEN_ALL; do
        CHECK_REVISION="${VER_NEW##*-}"
        CHECK_VERSION="${VER_NEW%-*}"
        if [ "$REVISION" != "$CHECK_REVISION" ]; then
            echo "Something wrong with revision: $PACKAGE $VER_OLD $VER_NEW $SOURCE $DEP $PREFIX $REST $REVISION $LEN_ALL"
            exit 1
        fi
        if [ "$PREFIX" = "-" ]; then
            if [ "$REST" != "$CHECK_VERSION" ]; then
                echo "Something wrong with rest: $PACKAGE $VER_OLD $VER_NEW $SOURCE $DEP $PREFIX $REST $REVISION $LEN_ALL"
                exit 1
            fi
        elif [ "$REST" = "-" ]; then
            if [ "$PREFIX" != "$CHECK_VERSION" ]; then
                echo "Something wrong with prefix: $PACKAGE $VER_OLD $VER_NEW $SOURCE $DEP $PREFIX $REST $REVISION $LEN_ALL"
                exit 1
            fi
        else
            if [ "$PREFIX$REST" != "$CHECK_VERSION" ]; then
                echo "Something wrong with prefix+rest: $PACKAGE $VER_OLD $VER_NEW $SOURCE $DEP $PREFIX $REST $REVISION $LEN_ALL"
                exit 1
            fi
        fi
        if [ "$SOURCE" = "P" ]; then
            if [ "$CAN_FETCH_PACMAN_ISSUES" -eq 1 ]; then
                ISSUES_CACHE_FILE="$ISSUES_CACHE_DIR"/issues."$PACKAGE".stamp-"$ISSUE_FILE_STAMP"
                if [ ! -e "$ISSUES_CACHE_FILE" ] && [ ! -e "${ISSUES_CACHE_FILE}.empty" ]; then
                    FETCH_ISSUES_PACMAN="$FETCH_ISSUES_PACMAN$PACKAGE "
                fi
            fi
            if [ "$CAN_FETCH_PACMAN_CHANGELOG" -eq 1 ]; then
                COMMITS_CACHE_FILE="$CHANGELOG_CACHE_DIR"/commits."$PACKAGE".stamp-"$ISSUE_FILE_STAMP"
                TAGS_CACHE_FILE="$CHANGELOG_CACHE_DIR"/tags."$PACKAGE".stamp-"$ISSUE_FILE_STAMP"
                if [ ! -e "$COMMITS_CACHE_FILE" ] || [ ! -e "$TAGS_CACHE_FILE" ]; then
                    FETCH_CHANGELOG_PACMAN="$FETCH_CHANGELOG_PACMAN$PACKAGE "
                fi
            fi
        elif [ "$SOURCE" = "A" ]; then
            if [ "$CAN_FETCH_AUR_CHANGELOG" -eq 1 ]; then
                COMMITS_CACHE_FILE="$CHANGELOG_CACHE_DIR"/commits."$PACKAGE".stamp-"$ISSUE_FILE_STAMP"
                if [ ! -e "$COMMITS_CACHE_FILE" ]; then
                    FETCH_CHANGELOG_AUR="$FETCH_CHANGELOG_AUR$PACKAGE "
                fi
            fi
        fi
    done < "$UPGRADE_PACKAGE_LIST_FILE"

    CURL_ERROR_COUNT=0

    if [ -n "$FETCH_CHANGELOG_PACMAN" ]; then

        CURL_OUTPUT_DIR="$(mktemp -d)"
        COUNT="$(echo "$FETCH_CHANGELOG_PACMAN" | wc -w)"

        stage "Generate URLs for changelogs from $COUNT pacman package(s)"
        PACKAGES_LIST_FILE="$CURL_OUTPUT_DIR"/packages.list
        CURL_CONFIG_FILE="$CURL_OUTPUT_DIR"/curl-config.list
        CURL_RESULT_FILE="$CURL_OUTPUT_DIR"/curl-result.list
        # shellcheck disable=SC2086
        TZ=UTC expac -Q -t "%FT%TZ" "%e %b %n" $FETCH_CHANGELOG_PACMAN > "$PACKAGES_LIST_FILE"
        RETRY_CHANGELOG_PACMAN="$(awk '{printf "%s ", $1}' "$PACKAGES_LIST_FILE")"

        while true; do

            cut -d' ' -f1-2 < "$PACKAGES_LIST_FILE" \
                | sort -u \
                | jq -Rr --arg pkg_list_data "$RETRY_CHANGELOG_PACMAN" --arg outputDir "$CURL_OUTPUT_DIR" '
                    ($pkg_list_data | split(" ")) as $pkg_list
                    | split("\n")
                    | .[]
                    | split(" ") as $p
                    | select($p[0] | IN($pkg_list[]))
                    | [
                        $p[0],
                        ($p[1] | @uri),
                        ("archlinux/packaging/packages/\($p[0])" | gsub("\\+"; "plus") | @uri)
                    ]
                    | "url=https://gitlab.archlinux.org/api/v4/projects/\(.[2])/repository/commits?since=\(.[1])"
                    + "\n"
                    + "output=\($outputDir)/commits.\(.[0]).json"
                    + "\n"
                    + "url=https://gitlab.archlinux.org/api/v4/projects/\(.[2])/repository/tags"
                    + "\n"
                    + "output=\($outputDir)/tags.\(.[0]).json"
                    + "\n"
                ' > "$CURL_CONFIG_FILE"

            stage "Download changelogs"
            curl --silent \
                --parallel --parallel-immediate --parallel-max 10 \
                --write-out "%{response_code} %{filename_effective}\n" \
                --config "$CURL_CONFIG_FILE" > "$CURL_RESULT_FILE"

            stage "Process changelogs"

            unset RETRY_CHANGELOG_PACMAN

            while read -r RESPONSE_CODE OUTPUT_FILE; do
                [ "$RESPONSE_CODE" != 200 ] || continue
                PACKAGE="${OUTPUT_FILE##*/}"
                KIND="${PACKAGE%%.*}"
                PACKAGE="${PACKAGE#*.}"
                PACKAGE="${PACKAGE%.*}"
                if [ "$RESPONSE_CODE" = 429 ]; then
                    RETRY_CHANGELOG_PACMAN="$RETRY_CHANGELOG_PACMAN$PACKAGE "
                    rm -f "$OUTPUT_FILE"
                elif [ "$RESPONSE_CODE" = 404 ]; then
                    echo "${H_BLACK}[${YELLOW}WARNING${H_BLACK}]${RESET} got ${RED}404${RESET} response code for $KIND of package: ${CYAN}$PACKAGE${RESET}"
                    rm -f "$OUTPUT_FILE"
                else
                    echo "${H_BLACK}[${RED}ERROR${H_BLACK}]${RESET} got ${RED}$RESPONSE_CODE${RESET} response code for $KIND of package: ${CYAN}$PACKAGE${RESET}"
                    rm -f "$OUTPUT_FILE"
                    CURL_ERROR_COUNT=$(( CURL_ERROR_COUNT + 1 ))
                fi
            done < "$CURL_RESULT_FILE"

            [ -n "$RETRY_CHANGELOG_PACMAN" ] || break

            echo
            echo "${YELLOW}Got rate limit for $(echo "$RETRY_CHANGELOG_PACMAN" | wc -w) URLs. Rate limit info:${RESET}"

            RETRY_AFTER=365

            TEMP_RATE_LIMIT_INFO="$(mktemp)"
            curl -sI "https://gitlab.archlinux.org/api/v4/projects/archlinux%2Fpackaging%2Fpackages%2Flinux/repository/commits" > "$TEMP_RATE_LIMIT_INFO"

            while read -r LINE; do
                case "$LINE" in
                    retry-after:*)
                        RETRY_AFTER="$(echo "${LINE#*: }" | tr -d '\r')"
                        ;;
                    ratelimit-*|x-ratelimit-*)
                        : no-op
                        ;;
                    *)
                        continue
                        ;;
                esac
                echo "    ${CYAN}${LINE%%: *}${H_BLACK}: ${RESET}${LINE#*: }"
            done < "$TEMP_RATE_LIMIT_INFO"

            rm -f "$TEMP_RATE_LIMIT_INFO"
            unset TEMP_RATE_LIMIT_INFO

            echo
            waitRateLimit "$RETRY_AFTER" "there will be another attempt to download these URLs..."

        done

        while read -r PACKAGE_BASE _ PACKAGE; do
            OUTPUT_COMMITS_FILE="$CURL_OUTPUT_DIR"/commits."$PACKAGE_BASE".json
            OUTPUT_TAGS_FILE="$CURL_OUTPUT_DIR"/tags."$PACKAGE_BASE".json
            rm -f "$CHANGELOG_CACHE_DIR"/commits."$PACKAGE".stamp-*
            rm -f "$CHANGELOG_CACHE_DIR"/tags."$PACKAGE".stamp-*
            if [ -e "$OUTPUT_COMMITS_FILE" ] && [ -e "$OUTPUT_TAGS_FILE" ]; then
                COMMITS_CACHE_FILE="$CHANGELOG_CACHE_DIR"/commits."$PACKAGE".stamp-"$ISSUE_FILE_STAMP"
                cp "$OUTPUT_COMMITS_FILE" "$COMMITS_CACHE_FILE"
                TAGS_CACHE_FILE="$CHANGELOG_CACHE_DIR"/tags."$PACKAGE".stamp-"$ISSUE_FILE_STAMP"
                cp "$OUTPUT_TAGS_FILE" "$TAGS_CACHE_FILE"
            fi
        done < "$PACKAGES_LIST_FILE"

        rm -rf "$CURL_OUTPUT_DIR"
        unset CURL_OUTPUT_DIR

    fi

    if [ -n "$FETCH_CHANGELOG_AUR" ]; then

        CURL_OUTPUT_DIR="$(mktemp -d)"
        COUNT="$(echo "$FETCH_CHANGELOG_AUR" | wc -w)"

        stage "Generate URLs for changelogs from $COUNT AUR package(s)"
        CURL_CONFIG_FILE="$CURL_OUTPUT_DIR"/curl-config.list
        CURL_RESULT_FILE="$CURL_OUTPUT_DIR"/curl-result.list
        RETRY_CHANGELOG_AUR="$FETCH_CHANGELOG_AUR"

        while true; do

            echo "$RETRY_CHANGELOG_AUR" \
                | jq -Rr --arg outputDir "$CURL_OUTPUT_DIR" '
                    split(" ")
                    | .[]
                    | select(. | length > 0)
                    | [
                        .,
                        (. | @uri)
                    ]
                    | "url=https://api.github.com/repos/archlinux/aur/commits?sha=\(.[1])"
                    + "\n"
                    + "output=\($outputDir)/commits.\(.[0]).json"
                    + "\n"
                ' > "$CURL_CONFIG_FILE"

            stage "Download changelogs"
            curl --silent \
                --parallel --parallel-immediate --parallel-max 10 \
                --write-out "%{response_code} %{filename_effective}\n" \
                --config "$CURL_CONFIG_FILE" > "$CURL_RESULT_FILE"

            stage "Process changelogs"

            unset RETRY_CHANGELOG_AUR

            while read -r RESPONSE_CODE OUTPUT_FILE; do
                [ "$RESPONSE_CODE" != 200 ] || continue
                PACKAGE="${OUTPUT_FILE##*/}"
                KIND="${PACKAGE%%.*}"
                PACKAGE="${PACKAGE#*.}"
                PACKAGE="${PACKAGE%.*}"
                if [ "$RESPONSE_CODE" = 429 ]; then
                    RETRY_CHANGELOG_AUR="$RETRY_CHANGELOG_AUR$PACKAGE "
                    rm -f "$OUTPUT_FILE"
                elif [ "$RESPONSE_CODE" = 404 ]; then
                    echo "${H_BLACK}[${YELLOW}WARNING${H_BLACK}]${RESET} got ${RED}404${RESET} response code for $KIND of package: ${CYAN}$PACKAGE${RESET}"
                    rm -f "$OUTPUT_FILE"
                else
                    echo "${H_BLACK}[${RED}ERROR${H_BLACK}]${RESET} got ${RED}$RESPONSE_CODE${RESET} response code for $KIND of package: ${CYAN}$PACKAGE${RESET}"
                    rm -f "$OUTPUT_FILE"
                    CURL_ERROR_COUNT=$(( CURL_ERROR_COUNT + 1 ))
                fi
            done < "$CURL_RESULT_FILE"

            [ -n "$RETRY_CHANGELOG_AUR" ] || break

            echo
            echo "${YELLOW}Got rate limit for $(echo "$RETRY_CHANGELOG_AUR" | wc -w) packages. Rate limit info:${RESET}"

            RETRY_AFTER=365

            TEMP_RATE_LIMIT_INFO="$(mktemp)"
            curl -sI "https://api.github.com/repos/archlinux/aur/commits?sha=linux" > "$TEMP_RATE_LIMIT_INFO"

            while read -r LINE; do
                case "$LINE" in
                    retry-after:*)
                        RETRY_AFTER="$(echo "${LINE#*: }" | tr -d '\r')"
                        ;;
                    ratelimit-*|x-ratelimit-*)
                        : no-op
                        ;;
                    *)
                        continue
                        ;;
                esac
                echo "    ${CYAN}${LINE%%: *}${H_BLACK}: ${RESET}${LINE#*: }"
            done < "$TEMP_RATE_LIMIT_INFO"

            rm -f "$TEMP_RATE_LIMIT_INFO"
            unset TEMP_RATE_LIMIT_INFO

            echo
            waitRateLimit "$RETRY_AFTER" "there will be another attempt to download changelogs for there packages..."

        done

        for PACKAGE in $FETCH_CHANGELOG_AUR; do
            OUTPUT_COMMITS_FILE="$CURL_OUTPUT_DIR"/commits."$PACKAGE".json
            rm -f "$CHANGELOG_CACHE_DIR"/commits."$PACKAGE".stamp-*
            if [ -e "$OUTPUT_COMMITS_FILE" ]; then
                COMMITS_CACHE_FILE="$CHANGELOG_CACHE_DIR"/commits."$PACKAGE".stamp-"$ISSUE_FILE_STAMP"
                cp "$OUTPUT_COMMITS_FILE" "$COMMITS_CACHE_FILE"
            fi
        done

        rm -rf "$CURL_OUTPUT_DIR"
        unset CURL_OUTPUT_DIR

    fi

    if [ -n "$FETCH_ISSUES_PACMAN" ]; then

        CURL_OUTPUT_DIR="$(mktemp -d)"
        COUNT="$(echo "$FETCH_CHANGELOG_PACMAN" | wc -w)"

        stage "Generate URLs for issues from $COUNT pacman package(s)"
        PACKAGES_LIST_FILE="$CURL_OUTPUT_DIR"/packages.list
        CURL_CONFIG_FILE="$CURL_OUTPUT_DIR"/curl-config.list
        CURL_RESULT_FILE="$CURL_OUTPUT_DIR"/curl-result.list
        # shellcheck disable=SC2086
        TZ=UTC expac -Q -t "%FT%TZ" "%e %b %n" $FETCH_ISSUES_PACMAN > "$PACKAGES_LIST_FILE"
        RETRY_ISSUES_PACMAN="$(awk '{printf "%s ", $1}' "$PACKAGES_LIST_FILE")"

        while true; do

            cut -d' ' -f1-2 < "$PACKAGES_LIST_FILE" \
                | sort -u \
                | jq -Rr --arg pkg_list_data "$RETRY_ISSUES_PACMAN" --arg outputDir "$CURL_OUTPUT_DIR" '
                    ($pkg_list_data | split(" ")) as $pkg_list
                    | split("\n")
                    | .[]
                    | split(" ") as $p
                    | select($p[0] | IN($pkg_list[]))
                    | [
                        $p[0],
                        ($p[1] | @uri),
                        ("archlinux/packaging/packages/\($p[0])" | gsub("\\+"; "plus") | @uri)
                    ]
                    | "url=https://gitlab.archlinux.org/api/v4/projects/\(.[2])/issues?state=opened&created_after=\(.[1])"
                    + "\n"
                    + "output=\($outputDir)/issues.\(.[0]).json"
                    + "\n"
                ' > "$CURL_CONFIG_FILE"

            stage "Download issues"
            curl --silent \
                --parallel --parallel-immediate --parallel-max 10 \
                --write-out "%{response_code} %{filename_effective}\n" \
                --config "$CURL_CONFIG_FILE" > "$CURL_RESULT_FILE"

            stage "Process issues"

            # Delete 'empty' files (exactly 2 bytes '[]')
            find "$CURL_OUTPUT_DIR" -type f -size 2c -delete

            unset RETRY_ISSUES_PACMAN

            while read -r RESPONSE_CODE OUTPUT_FILE; do
                [ "$RESPONSE_CODE" != 200 ] || continue
                PACKAGE="${OUTPUT_FILE##*/}"
                PACKAGE="${PACKAGE#*.}"
                PACKAGE="${PACKAGE%.*}"
                if [ "$RESPONSE_CODE" = 429 ]; then
                    RETRY_ISSUES_PACMAN="$RETRY_ISSUES_PACMAN$PACKAGE "
                    rm -f "$OUTPUT_FILE"
                elif [ "$RESPONSE_CODE" = 404 ]; then
                    echo "${H_BLACK}[${YELLOW}WARNING${H_BLACK}]${RESET} got ${RED}404${RESET} response code for package: ${CYAN}$PACKAGE${RESET}"
                    mv "$OUTPUT_FILE" "${OUTPUT_FILE}.error"
                else
                    echo "${H_BLACK}[${RED}ERROR${H_BLACK}]${RESET} got ${RED}$RESPONSE_CODE${RESET} response code for package: ${CYAN}$PACKAGE${RESET}"
                    mv "$OUTPUT_FILE" "${OUTPUT_FILE}.error"
                    CURL_ERROR_COUNT=$(( CURL_ERROR_COUNT + 1 ))
                fi
            done < "$CURL_RESULT_FILE"

            [ -n "$RETRY_ISSUES_PACMAN" ] || break

            echo
            echo "${YELLOW}Got rate limit for $(echo "$RETRY_ISSUES_PACMAN" | wc -w) packages. Retry limit info:${RESET}"

            RETRY_AFTER=365

            TEMP_RATE_LIMIT_INFO="$(mktemp)"
            curl -sI "https://gitlab.archlinux.org/api/v4/projects/archlinux%2Fpackaging%2Fpackages%2Flinux/issues" > "$TEMP_RATE_LIMIT_INFO"

            while read -r LINE; do
                case "$LINE" in
                    retry-after:*)
                        RETRY_AFTER="$(echo "${LINE#*: }" | tr -d '\r')"
                        ;;
                    ratelimit-*|x-ratelimit-*)
                        : no-op
                        ;;
                    *)
                        continue
                        ;;
                esac
                echo "    ${CYAN}${LINE%%: *}${H_BLACK}: ${RESET}${LINE#*: }"
            done < "$TEMP_RATE_LIMIT_INFO"

            rm -f "$TEMP_RATE_LIMIT_INFO"
            unset TEMP_RATE_LIMIT_INFO

            echo
            waitRateLimit "$RETRY_AFTER" "there will be another attempt to download issues for there packages..."

        done

        while read -r PACKAGE_BASE _ PACKAGE; do
            OUTPUT_FILE="$CURL_OUTPUT_DIR"/issues."$PACKAGE_BASE".json
            ISSUES_CACHE_FILE="$ISSUES_CACHE_DIR"/issues."$PACKAGE".stamp-"$ISSUE_FILE_STAMP"
            rm -f "$ISSUES_CACHE_DIR"/issues."$PACKAGE".stamp-*
            if [ -e "$OUTPUT_FILE" ]; then
                cp "$OUTPUT_FILE" "$ISSUES_CACHE_FILE"
            elif [ ! -e "${OUTPUT_FILE}.error" ]; then
                # this is 'touch' without calling external tool
                printf '' > "${ISSUES_CACHE_FILE}.empty"
            fi
        done < "$PACKAGES_LIST_FILE"

        rm -rf "$CURL_OUTPUT_DIR"
        unset CURL_OUTPUT_DIR

    fi

    if [ "$CURL_ERROR_COUNT" -gt 0 ]; then
        echo
        printf "Press Enter to continue..."
        read -r _
    fi

    # We don't cleanup "$PACKAGE_INFO_CACHE_DIR/archlog".* here as
    # this directory may contain also logs from AUR fetched by arch-log.
    rm -f "$PACKAGE_INFO_CACHE_DIR/issues".*
    if [ "$CAN_FETCH_PACMAN_CHANGELOG" -eq 1 ] && [ "$CAN_FETCH_PACMAN_ISSUES" -eq 1 ]; then
        stage "Render changelogs and issues"
    elif [ "$CAN_FETCH_PACMAN_CHANGELOG" -eq 1 ]; then
        stage "Render changelogs"
    elif [ "$CAN_FETCH_PACMAN_ISSUES" -eq 1 ]; then
        stage "Render issues"
    fi

    UPGRADE_PACKAGE_TEMP_LIST_FILE="$(mktemp)"
    while read -r PACKAGE VER_OLD VER_NEW SOURCE DEP PREFIX REST REVISION LEN_ALL; do

        AGE="-"
        ISSUES_COUNT=0

        if [ "$SOURCE" = "P" ]; then

            if [ "$CAN_FETCH_PACMAN_ISSUES" -eq 1 ]; then

                ISSUES_CACHE_FILE="$ISSUES_CACHE_DIR"/issues."$PACKAGE".stamp-"$ISSUE_FILE_STAMP"

                if [ -e "$ISSUES_CACHE_FILE" ]; then

                    PACKAGE_INFO_CACHE_ISSUES="$PACKAGE_INFO_CACHE_DIR/issues.$PACKAGE"

                    # shellcheck disable=SC2086
                    jq -r $JQ_COLORS '
                      .[]
                      | (
                          .description
                          | gsub("<!--[^>]*-->"; "")
                          | gsub("(^|\\n+)(?<hash>#+\\s+)(?<title>.*)\\n+"; "\n\n" + $H_MAGENTA + .hash + $MAGENTA + .title + $RESET + "\n\n")
                          | gsub("(^|\\n+)```(?<type>[^\n]*)(?<code>.+)\\n```"; "\n\n" + $H_BLACK + "```" + $BLUE + .type + $GREEN + .code + "\n" + $H_BLACK + "```" + $RESET; "m")
                          | gsub("`(?<text>[^`\\n]+)`"; $H_BLACK + "`" + $GREEN + .text + $H_BLACK + "`" + $RESET)
                          | gsub("^\\n+"; "")
                          | gsub("\\n+$"; "")
                          | gsub("\\n{2,}"; "\n\n")
                        ) as $description
                      | $RED + "Issue" + $H_BLACK + "#" + $H_RED + "\(.iid)" + $H_BLACK + ": " + $RESET + .title + "\n" +
                        $CYAN + "Created" + $H_BLACK + ": " + $RESET + .created_at + "\n" +
                        $CYAN + "URL" + $H_BLACK + ": " + $H_BLUE + .web_url + $RESET + "\n" +
                        $CYAN + "Description" + $H_BLACK + ":" + $RESET + "\n\n" +
                        $description + "\n"
                    ' "$ISSUES_CACHE_FILE" > "$PACKAGE_INFO_CACHE_ISSUES"

                    ISSUES_COUNT="$(jq 'length' "$ISSUES_CACHE_FILE")"

                fi

            fi

            if [ "$CAN_FETCH_PACMAN_CHANGELOG" -eq 1 ]; then

                COMMITS_CACHE_FILE="$CHANGELOG_CACHE_DIR"/commits."$PACKAGE".stamp-"$ISSUE_FILE_STAMP"
                TAGS_CACHE_FILE="$CHANGELOG_CACHE_DIR"/tags."$PACKAGE".stamp-"$ISSUE_FILE_STAMP"

                if [ -e "$COMMITS_CACHE_FILE" ] && [ -e "$TAGS_CACHE_FILE" ]; then

                    PACKAGE_INFO_CACHE_ARCHLOG="$PACKAGE_INFO_CACHE_DIR/archlog.$PACKAGE"

                    # shellcheck disable=SC2086
                    jq -r $JQ_COLORS --slurpfile tags_data "$TAGS_CACHE_FILE" '
                      (INDEX($tags_data[][]; .commit.id)) as $tags
                      | map(. + {
                          "tag": ($tags[.id].name | if (. == null or . == "") then "" else "(\(.))" end)
                        }) as $commits
                      | ([$commits[] | .tag | length] | max) as $max_w
                      | $commits[]
                      | "\($GREEN)* \($YELLOW + (.created_at | split("T"))[0]) \( " " * ($max_w - (.tag | length)))\($GREEN + .tag) \($RESET + .title)"
                    ' "$COMMITS_CACHE_FILE" > "$PACKAGE_INFO_CACHE_ARCHLOG"

                    AGE="$(jq -r --argjson threshold "$AGE_THRESHOLD" '
                      (.[0].created_at | split(".")[0] + "Z") as $commit_date
                      | ([ (now - ($commit_date | fromdateiso8601)), 3600 ] | max) as $diff
                      | if ($diff > $threshold) then
                          "-"
                        else
                          ($diff / 86400 | floor) as $days
                          | (($diff % 86400) / 3600 | floor) as $hours
                          | [
                              (if $days > 0 then "\($days)d" else empty end),
                              (if $hours > 0 then "\($hours)h" else empty end)
                            ]
                          | join("")
                        end
                    ' "$COMMITS_CACHE_FILE")"

                fi

            fi

        elif [ "$SOURCE" = "A" ]; then

            if [ "$CAN_FETCH_AUR_CHANGELOG" -eq 1 ]; then

                COMMITS_CACHE_FILE="$CHANGELOG_CACHE_DIR"/commits."$PACKAGE".stamp-"$ISSUE_FILE_STAMP"

                if [ -e "$COMMITS_CACHE_FILE" ]; then

                    PACKAGE_INFO_CACHE_ARCHLOG="$PACKAGE_INFO_CACHE_DIR/archlog.$PACKAGE"

                    # shellcheck disable=SC2086
                    jq -r $JQ_COLORS '
                      .[]
                      | "\($GREEN)* \($YELLOW + (.commit.committer.date | split("T"))[0]) \($RESET + .commit.message)"
                    ' "$COMMITS_CACHE_FILE" > "$PACKAGE_INFO_CACHE_ARCHLOG"

                    AGE="$(jq -r --argjson threshold "$AGE_THRESHOLD" '
                      .[0].commit.committer.date as $commit_date
                      | ([ (now - ($commit_date | fromdateiso8601)), 3600 ] | max) as $diff
                      | if ($diff > $threshold) then
                          "-"
                        else
                          ($diff / 86400 | floor) as $days
                          | (($diff % 86400) / 3600 | floor) as $hours
                          | [
                              (if $days > 0 then "\($days)d" else empty end),
                              (if $hours > 0 then "\($hours)h" else empty end)
                            ]
                          | join("")
                        end
                    ' "$COMMITS_CACHE_FILE")"

                fi

            fi

        else
            echo "That's not supposed to happen." >&2
            exit 1
        fi

        echo "$PACKAGE" "$VER_OLD" "$VER_NEW" "$SOURCE" "$DEP" "$PREFIX" "$REST" "$REVISION" "$LEN_ALL" "$AGE" "$ISSUES_COUNT"

    done < "$UPGRADE_PACKAGE_LIST_FILE" > "$UPGRADE_PACKAGE_TEMP_LIST_FILE"

    mv -f "$UPGRADE_PACKAGE_TEMP_LIST_FILE" "$UPGRADE_PACKAGE_LIST_FILE"
    unset UPGRADE_PACKAGE_TEMP_LIST_FILE

    SELECTED="$("$SELF_FILE" -list | fzf --ansi --disabled --reverse --no-input \
        --highlight-line \
        --footer "$FOOTER" \
        --footer-border --footer-label "[ Keyboard shortcuts ]" --footer-label-pos 3:top \
        --preview "'$SELF_FILE' -preview {}" \
        --preview-border --preview-label "[ Package details ]" --preview-label-pos 3:top \
        --preview-window wrap \
        --header "Select the packages to upgrade:" \
        --header-border \
        --bind "space:execute-silent('$SELF_FILE' -toggle-skip {})+reload-sync('$SELF_FILE' -list)+down" \
        --bind "ctrl-s:execute-silent('$SELF_FILE' -toggle-group {})+reload-sync('$SELF_FILE' -list)" \
        --bind "ctrl-a:execute-silent('$SELF_FILE' -upgrade-all)+reload-sync('$SELF_FILE' -list)" \
        --bind "ctrl-u:execute-silent('$SELF_FILE' -skip-all)+reload-sync('$SELF_FILE' -list)" \
        --bind "enter:execute-silent('$SELF_FILE' -open-url {})" \
        --bind "?:toggle-preview+reload-sync('$SELF_FILE' -list)" \
        --bind "resize:reload-sync('$SELF_FILE' -list)" \
        --bind "alt-enter:become(echo {})")" || exit 0

    [ -n "$SELECTED" ] || exit 0

    UPGRADE_SKIP_LIST=" $(cat "$UPGRADE_SKIP_LIST_FILE") "

    set --
    while read -r PACKAGE _ VER_NEW SOURCE _; do
        if [ "$SOURCE" = "P" ]; then
            if [ "${UPGRADE_SKIP_LIST#*" $PACKAGE "}" = "$UPGRADE_SKIP_LIST" ]; then
                set -- "$@" "${PACKAGE}=${VER_NEW}"
            fi
        fi
    done < "$UPGRADE_PACKAGE_LIST_FILE"

    if [ $# -eq 0 ]; then
        echo
        echo "There are no pacman packages to update."
    else

        echo
        echo "Upgrade pacman package database ..."
        sudo pacman -Sy

        echo
        echo "Check pacman upgrade ..."

        if ! OUTPUT="$(pacman -Sp "$@" --color always)"; then
            echo "$OUTPUT"
            echo
            echo "${RED}Update check failed. Check the error output from the pacman command."
            echo "You may need to mark additional packages as dependencies, or the repository"
            echo "may already have newer versions available than the selected ones."
            echo
            echo "The package list will be updated and you will be returned to selection mode.${RESET}"
            echo
            printf "Press Enter to continue..."
            read -r _
            continue
        fi

        echo "Run pacman upgrade ..."
        sudo pacman -S "$@" --color always

    fi

    set --
    while read -r PACKAGE _ VER_NEW SOURCE _; do
        if [ "$SOURCE" = "A" ]; then
            if [ "${UPGRADE_SKIP_LIST#*" $PACKAGE "}" = "$UPGRADE_SKIP_LIST" ]; then
                set -- "$@" "${PACKAGE}"
            fi
        fi
    done < "$UPGRADE_PACKAGE_LIST_FILE"

    if [ $# -eq 0 ]; then
        echo
        echo "There are no AUR packages to update."
    else
        echo
        echo "Run AUR upgrade ..."
        yay -S "$@" --color always \
            --noconfirm --sudoloop --needed \
            --answerclean None --answerdiff None \
            --answeredit None --answerupgrade None
    fi

    echo
    echo "${GREEN}All done!${RESET}"
    exit 0

done
